# APG4b備忘録

## 1.12.文字列と文字
### 文字列 `string`
- 文字列の長さ `str.size()`
- $i$番目の文字 `str.at()`
- 文字列に直接メンバ関数や演算子を適用するとき
  `"string".size()`と書いた場合コンパイルエラーになる．
  - 一度変数に格納する．
  - `"string"s.size()`のように`""`の末尾に`s`をつける必要がある．

### 細かい話
- 文字列の連結
  - `+`演算子を使うと文字列同士を連結できる．
- 文字列文字の連結
  - `string`と`char`を`+`すると
    文字列同士と同様に連結できる．
- 行単位での入力
  - `cin`を使うと空白や改行区切りの入力を簡単に扱える．
  - 空白で区切らず行単位で入力を受け取りたい場合は`getline`を使う．

## 1.13 配列
- 配列変数の宣言 `vector<type> vec;`
- 配列変数への代入 `vec = {elem1, elem2, ...}`
- 配列の初期化1 `vector<type> vec(要素数)`
- 配列の初期化2 `vector<type> vec(要素数, 初期値)`
- $i$番目の要素 `vec.at(i)`
- 配列の要素数 `vec.size()`
- 要素の追加 `vec.push_back(elem)`
<!-- ！十分な大きさで配列を初期化しておくこと -->
- 末尾要素の削除 `vec.pop_back()`
- 配列同士の比較
  - 配列変数同士は`==`で比較することができる．
  - 全要素が一致していたとき`true`となる．

## 1.14.STLの関数
| 関数         | 機能 |
| ------------ | ---- |
| `min(a,b)`   |      |
| `max(a, b)`  |      |
| `swap(a, b)` |      |

| 関数                              | 機能 |
| --------------------------------- | ---- |
| `sort(vec.begin(), vec.end())`    |      |
| `reverse(vec.begin(), vec.end())` |      |

## 2.01.ループの書き方と範囲`for`文
### 範囲`for`文
範囲`for`文はコンテナと呼ばれるデータ型に対して使うことができる．配列と`string`型はコンテナの一種である．範囲`for`文の基本的な構文を以下に示す．
```C++
for (type elem : vec) {
  // code here
}
```

## 2.02.多重ループ
- 多重ループを一度に抜けたい場合は，基本的にフラグ変数を用意する方針で処理する．
- `return`を使って一気に抜けるという方法もある．

## 2.03.多次元配列
- 初期化1
  - `vector<vector<type>> vec(要素数, vector<type>(要素数, 初期値))`
  - 初期値を省略した場合は`type`に対応するゼロ値で初期化される．
  - 例えば，要素の型が`int`なら`0`，`string`なら`""`で初期化される．
- 初期化2

```C++
vector<vector<int>> data = {
  {7, 4, 0, 8},
  {2, 0, 3, 5},
  {6, 1, 7, 0},
};
```

- $N \times 0$の二次元配列
  - 後から要素を追加して使う場合に，$N \times 0$の配列を宣言できる．
  - `vector<vector<type>> vec(N);`
  - 後から要素を追加していくと，行毎に要素数の異なる
    **ジャグ配列**ができることがある．

## 2.04.参照
- 宣言 `type &b = a`
  - ！参照先が定まっていない参照を作ることはできない
  - ！参照先を変更する事はできない -> ポインタとの相違点
    - 参照の機能を使うと，ある変数に別名を付けることができる．
    - 関数の参照渡しは，無駄なコピーを避けたり
      複数の結果を返したいときに便利

### 範囲`for`文での参照
参照は範囲`for`文でも用いることができ，
これによって配列の要素を書き換える処理を簡潔に書くことができる．

```C++
vector<int> a = {1, 3, 2, 5};
for (int &x : a) {
  x = x * 2;
}
```

# 2.05.再帰関数
## 再帰関数の性質
- ペースステップ  
  再帰呼び出しを行わずに完了できる処理
- 再帰ステップ  
  再帰呼び出しを行い，その結果を用いて行う処理

## 再帰関数の実装法
1. 引数，返り値，処理内容を決める
  - `sum()`関数での例

|         |                    |
| --------| -------------------|
| 引数    | `int n`             |
| 返り値   | $0 \sim n$ の総和    |
| 処理内容 | $\uparrow$ を計算する |

2. 再帰ステップの実装
3. ベースケースの実装

### 細かい話
#### 発展的な例
- 途中で出力する例
- グリッド上の迷路の探索  
  迷路に見立てたマス目のスタート地点から
  ゴールまで到達することができるか判定する．
  - 上下左右への移動を行えるか確認する．
  - 移動できるなら移動先からゴールまで到達できるかを調べる．
  - 一度調べたマス目を再び調べることがないようにする必要  
    $\because$ 無限ループ防止

## 2.06.計算量
### STL関数の計算量

|           |              |
| --------- | ------------ |
| `sort`    | $O(N\log N)$ |
| `reverse` | $O(N)$       |

## 3.01.数値型
`int??_t`系や`uint??_t`系を推奨

### 細かい話
#### 文字列との変換
- 数値 -> 文字列 `to_string()`関数
- 文字列 -> 数値

| 型       | 変換関数  |
| -------- | --------- |
| `int`    | `stoi()`  |
| `long`   | `stoll()` |
| `double` | `stod()`  |

AtCoder上では`long`が扱える範囲は`int64_t`と同じになる．

#### 他の数値型
- `size_t`  
- 配列や文字列の`size()`で返ってくる要素数の値．
- C++ (GCC 9.2.1) においては
  `unsigned long`として定義されている．

## 3.02.`pair`/`tuple`と`auto`

### `pair`/`tuple`
#### `pair`
- 2つの値の組を表す．
- 宣言 `pair<type1, type2> 変数名`
- 初期化 `pair<type1, type2> 変数名(val1, val2)`
- アクセス `pair.first`，`pair.second`
- `pair`の生成 `make_pair(val1, val2)`
- `pair`の分解 `tie(var1, var2) = pair;`
- `ignore`を`tie`の引数に渡すことで
  対応する位置の値を捨てることができる．

#### `tuple`
- 複数の値の組を表す．
- `pair`を一般化した型

#### `auto`
- 宣言 `tuple<type1, type2, ...> 変数名;`
- 初期化 `tuple<type1, type2, ...> 変数名(val1, val2, ...);`
- アクセス `get<K> tuple`
- `tuple`の生成 `make_tuple(val1, val2, ...)`
- `tuple`の分解 `tie(val1, val2, ...) = tuple;`
- `pair`と同様に`ignore`で捨てることができる．

#### `pair`/`tuple`の比較
- 型が同じ`pair`や`tuple`同士は比較することができる．
- 1番目の値から順に比較される．

#### `auto`
- 変数宣言や範囲`for`文において，型の部分に
  `auto`と書くことによって型を省略できる．
- 変数宣言での`auto` `auto 変数名 = 初期値;`
- 範囲`for`文での`auto`

```C++
for (auto elem : vec) {
  // code here
}
```

### 細かい話
#### 型エイリアス `using 新型名 = 型名;`
`pair`や`tuple`など型名が長くなってしまう場合に型エイリアスを使うと便利

```C++
using vi = vector<int>;
using vvi = vector<vi>;

int N = 10, M = 20;
vvi data(N, vi(M));
```

##  3.03.STLのコンテナ
### `map`
- 連想配列や辞書と呼ばれるデータ構造
- 宣言 `map<key_type, value_type> 変数名;`
- 操作  

| 操作      | 記法                | 計算量      |
| -------- | ------------------ | ---------- |
| 追加      | `map[key] = value;`| $O(\log N)$ |
| 削除      | `map.erase(key)`   | $O(\log N)$ |
| アクセス   | `map.at(key)`      | $O(\log N)$ |
| 所属判定   | `map.count(key)`   | $O(\log N)$ |
| 要素数取得 | `map.size()`       | $O(1)$      |

- ! `[]`で存在しないKeyにアクセスした場合新しいデータが追加される．
- ループ  
  - Keyの値が小さい順に取り出される．

```C++
for (pair<key_type, value_type> p : map) {
  kay_type key = p.first;
  value_type value = p.second;
  // code here
}
```

### `set`
- 重複の無いデータのまとまりを扱うためのデータ構造
- 宣言 `set<type> 変数名`
- 操作

| 操作       | 記法                | 計算量      |
| --------- | ------------------- | ---------- |
| 追加      | `set.insert(value)` | $O(\log N)$ |
| 探索      | `set.find(value)`   | $O(\log N)$ |
| 削除      | `set.erase(value)`  | $O(\log N)$ |
| 所属判定   | `set.count(value)`  | $O(\log N)$ |
| 要素数取得 | `set.size()`        | $O(1)$      |
| 最小値取得 | `*begin(set)`       | $O(1)$      |
| 最大値取得 | `*rbegin(set)`      | $O(1)$      |
| 空判定     | `set.empty()`       | $O(1)$      |

### `stack`
- 宣言 `stack<type> 変数名`
- 操作

| 操作           | 記法                | 計算量 |
| -------------- | ------------------- | ------ |
| 追加           | `stack.push(value)` | $O(1)$ |
| 末尾要素の取得 | `stack.top()`       | $O(1)$ |
| 末尾要素の削除 | `stack.pop()`       | $O(1)$ |
| 要素数取得     | `stack.size()`      | $O(1)$ |
| 空判定         | `stack.empty()`     | $O(1)$ |

### `queue`
幅優先探索に用いられる
- 宣言 `queue<type> 変数名;`
- 操作

| 操作           | 記法                | 計算量 |
| -------------- | ------------------- | ------ |
| 追加           | `queue.push(value)` | $O(1)$ |
| 先頭要素の取得 | `queue.front()`     | $O(1)$ |
| 先頭要素の削除 | `queue.pop()`       | $O(1)$ |
| 要素数取得     | `queue.size()`      | $O(1)$ |
| 空判定         | `queue.empty()`     | $O(1)$ |

### `priority_queue`
- 優先度付きキューと呼ばれるデータ構造
- 普通の待ち行列とは違って，行列に入れられた順序は
  取り出される順序には何の影響も与えない．
- ダイクストラ法などで用いられる．
- 宣言 `priority_queue<型> 変数名;`
- 値が小さい順に取り出される`priority_queue`の宣言
  - `priority_queue<type, vector<type>, greater<type>> 変数名;`
- 操作

| 操作           | 記法                | 計算量      |
| -------------- | ------------------- | ----------- |
| 追加           | `queue.push(value)` | $O(\log N)$ |
| 最大要素の取得 | `queue.top()`       | $O(1)$      |
| 最大要素の削除 | `queue.pop()`       | $O(\log N)$ |
| 要素数取得     | `queue.size()`      | $O(1)$      |
| 空判定         | `queue.empty()`     | $O(1)$      |

### コピーや計算量の比較
- STLのコンテナをコピー・比較するときにかかる計算量は$O(N)$である．
- 要素の沢山あるコンテナを頻繁にコピーするコードは
  計算量が大きくなってしまうため注意が必要である．

### 細かい話
#### `deque`
- 両端キューというデータ構造
- 「最初に追加したものを取り出す」という`queue`の操作と
- 「最後に追加した要素を取り出す」という`stack`の操作を
  同時に行える．
- 宣言 `deque<type> 変数名`
- 操作

| 操作          | 記法                      | 計算量  |
| ------------ | ------------------------- | ------ |
| 末尾への追加   | `deque.push_back(value)`  | $O(1)$ |
| 先頭への追加   | `deque.push_front(value)` | $O(1)$ |
| 先頭要素の取得 | `deque.front()`           | $O(1)$ |
| 末尾要素の取得 | `deque.back()`            | $O(1)$ |
| $i$ 番目の取得 | `deque.at(i)`            | $O(1)$ |
| 先頭要素の削除 | `deque.pop_front()`       | $O(1)$ |
| 末尾要素の削除 | `deque.pop_back()`        | $O(1)$ |
| 要素数取得     | `deque.size()`           | $O(1)$ |
| 空判定        | `deque.empty()`           | $O(1)$ |

- ！空の`deque`に対して`front()`や`back()`を読んだ時の動作は未定義

#### `unordered_map`
- 基本的な機能は`map`と同じだが
  アクセスや探索を高速に行うことができる．
- 制約
  - ハッシュ関数が定義されていない型？をKeyとして用いることができない．
    - i.e. `pair`，`tuple`
  - ループで取り出す時にどのような順番で取り出されるか分からない．
- 計算量

| 操作                | 計算量 |
| ------------------ | ------ |
| 追加 `[]`           | $O(1)$ |
| 削除 `erase()`      | $O(1)$ |
| アクセス `at()`     | $O(1)$ |
| 所属判定 `count()`  | $O(1)$ |
| 要素数取得 `size()` | $O(1)$ |

#### `unordered_set`
- `unordered_map`と同様に制約がある代わりに高速な`set`
- 制約
  - ハッシュ関数が定義されていない型？をKeyとして用いることができない．
  - ループで取り出す時にどのような順番で取り出されるか分からない．
- 計算量

| 操作                | 計算量 |
| ------------------- | ------ |
| 追加 `insert()`     | $O(1)$ |
| 削除 `erase()`      | $O(1)$ |
| アクセス `at()`？   | $O(1)$ |
| 所属判定 `count()`  | $O(1)$ |
| 要素数取得 `size()` | $O(1)$ |

#### `lower_bound()`/`upper_bound()`
**昇順にソートされた**配列に対して
- 「ある値**以上**の最小の要素」を求める場合には
  STLの`lower_bound()`を使うことができる．
- 「ある値を**超える**最小の要素」を求めるときには
  `upper_bound()`を使うことができる．
- 計算量はどちらも$O(\log N)$

```C++
*lower_bound(vec.begin(), vec.end(), threshold)
*upper_bound(vec.begin(), vec.end(), threshold)
```

## 3.04.構造体
- C++ではメンバ変数だけでなくメンバ関数も定義できる．
<!-- - もはやクラス同然 -->
- 定義 クラスと同様
- 宣言 `struct_name 変数名`
- 初期化  
  - `auto 変数名 = struct_name();`
  - `struct_name 変数名 = {value1, balue2, ...};`

### 細かい話
#### コピーコンストラクタ
- 次のような条件を満たした場合に呼ばれる．
- 関数の引数としてインスタンスを渡した場合
- `struct_name new_obj = old_obj;`で初期化する場合
- `struct_name new_obj(old_obj);`で初期化する場合

#### コピーコンストラクタを定義しなかった場合
- 「全てのメンバ変数をそのままコピーして新しいオブジェクトを作る」
- コピーコンストラクタが自動的に作られるため，ただコピーしたいだけなら
  コピーコンストラクタを自分で書く必要はない．

#### 演算子オーバーロード
```C++
struct struct_name {
  ...
  return_type operator演算子(type param) {
    // code here
  }
};

```
#### 代入演算子のオーバーロード
オーバーロードしなかった場合
「全てのメンバ変数をそのまま代入していく」
代入演算子`=`が自動的に定義される．

#### 外側で定義する場合
自分が定義していない構造体に対しても
演算子をオーバーロードすることができる．

```C++
/* .secondを優先して比較 */
bool operator<(pair<int, int> l, pair<int, int> r) {
  if (l.second != r.second) {
    return l.second < r.second;
  } else {
    return l.first < r.first;
  }
}

// <を利用して定義
bool operator> (pair<int, int> l, pair<int, int> r) { return r < l; }
bool operator<=(pair<int, int> l, pair<int, int> r) { return !(r < l); }
bool operator>=(pair<int, int> l, pair<int, int> r) { return !(l < r); }
```

#### STLのコンテナの要素として使う場合の注意
- 次のような場合には比較演算子`<`をオーバーロードする必要がある．
- `map`のKeyとして構造体を使う場合
- `priority_queue`の要素の型として構造体を使う
- 構造体の配列に対して`sort`関数を使う場合

#### メンバ初期化子リスト
- コンストラクタ初期化子のこと．
- コンストラクタ内の代入よりも基本的にはこちらを使う．

#### クラスとの相違点
アクセス指定の有無
- メンバ関数の中からしか扱えないメンバ変数
- メンバ関数の中でしか呼べないメンバ関数

## 3.05.ビット演算
C++でビット列を扱うには`bistset`を用いる．
- 宣言・初期化

```C++
bitset<ビット数> 変数名;  // 全ビットが0で初期化される
bitset<ビット数> 変数名("ビット列");
```

- ！ビット数の指定に変数は使えない
- 操作

| 操作           | 記法                 |
| -------------- | -------------------- |
| 全ビットを1    | `変数.set()`         |
| 全ビットを0    | `変数.reset()`       |
| 特定ビット変更 | `変数.set(pos, val)` |
| 全ビット反転   | `変数.flip()`        |
| 特定ビット反転 | `変数.flip(pos)`     |
| 特定ビット判定 | `変数.test(pos)`     |
| 全ビット判定   | `変数.all()`         |
|                | `変数.any()`       |
| 1ビットの個数  | `変数.count()`       |
| アクセス       | `変数[pos]`          |

- ！位置は右から0, 1, 2, ...と対応する．

### 演算子の優先順位
- ビット演算に用いる演算子は優先順位の低いものが多い．
- 優先順位を全て暗記するのは大変なので
  ビット演算を行う際には常に`()`で括る．

### 細かい話
#### ビット全探索の雛形
- 重複順列の実装に使える．

```C++
for (int tmp = 0; tmp < (1 << k); tmp++) {
  bitset<ビット数> s(tmp);
  // code here
}
```

- ！ビット数を$N$として$2^N$回のループになるので計算量に注意
> 2の$k$乗の値を得るために `1 << k` という書き方をよくする．  
> シンプルな形なので覚えておくこと．

#### `bitset`と整数の相互変換
- 整数 -> `bitset`への変換  
  `bitset<ビット数> 変数名(int)`
- `bitset`->整数  
  `bitset.to_ullong()`

#### 2進数リテラル
`0b`に続けて01のビット列を書くと
2進数表記で整数を表せる．

#### 負数の右シフト
負の数を右シフトした場合は
算術シフトで符号ビットが保存される．

## 3.06.その他の機能
### ラムダ式
- 関数の内部で関数を定義できる．
- 短い関数をその場で定義したい時に便利．
- ラムダ式の記法
  - `auto 関数名 = [](type1 param1, type2 param2, ...){ /* code here */ }`
  - `[&]`と書くことでラムダ式外の変数を利用できる．
- ラムダ式による再帰関数

```C++
function<return_type(type1, type2, ...)> 関数名
  = [&](type1 param1, type2 param2, ...){
  /* code here */
}
```

- 具体例
  - `sort()`関数に自分で定義した比較関数を渡すことで
    大きい順にソートさせる．

```C++
#include <bits/stdc++.h>
using namespace std;

int main() {
  vector<int> v = { 2, 3, 1 };

  auto comp = [](int a, int b) { return a > b; };
  sort(v.begin(), v.end(), comp);

  cout << v[0] << endl; // v = {3, 2, 1}となる
}
```

### `next_permutaion()`関数
- 順列の全列挙を行う関数
- 使い方
  - `sort()`が必要なことに注意する．

```C++
sort(vec.begin(), vec.end());
do {
  // code here
} while (next_permutation(vec.begin(), vec.end()));
```

- 計算量
  - 配列の長さを$N$とすると$O(N!)$になる．
  - $N$が小さくても計算量は大きくなるので注意．

### `goto`文
多重ループからの脱出の最終手段
